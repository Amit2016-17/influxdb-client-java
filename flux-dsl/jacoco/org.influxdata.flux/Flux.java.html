<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Flux.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">The Flux DSL</a> &gt; <a href="index.source.html" class="el_package">org.influxdata.flux</a> &gt; <span class="el_source">Flux.java</span></div><h1>Flux.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.influxdata.flux;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.influxdata.flux.functions.AbstractParametrizedFlux;
import org.influxdata.flux.functions.CountFlux;
import org.influxdata.flux.functions.CovarianceFlux;
import org.influxdata.flux.functions.CumulativeSumFlux;
import org.influxdata.flux.functions.DerivativeFlux;
import org.influxdata.flux.functions.DifferenceFlux;
import org.influxdata.flux.functions.DistinctFlux;
import org.influxdata.flux.functions.DropFlux;
import org.influxdata.flux.functions.DuplicateFlux;
import org.influxdata.flux.functions.ExpressionFlux;
import org.influxdata.flux.functions.FilterFlux;
import org.influxdata.flux.functions.FirstFlux;
import org.influxdata.flux.functions.FromFlux;
import org.influxdata.flux.functions.GroupFlux;
import org.influxdata.flux.functions.IntegralFlux;
import org.influxdata.flux.functions.JoinFlux;
import org.influxdata.flux.functions.KeepFlux;
import org.influxdata.flux.functions.LastFlux;
import org.influxdata.flux.functions.LimitFlux;
import org.influxdata.flux.functions.MapFlux;
import org.influxdata.flux.functions.MaxFlux;
import org.influxdata.flux.functions.MeanFlux;
import org.influxdata.flux.functions.MinFlux;
import org.influxdata.flux.functions.PercentileFlux;
import org.influxdata.flux.functions.PivotFlux;
import org.influxdata.flux.functions.RangeFlux;
import org.influxdata.flux.functions.RenameFlux;
import org.influxdata.flux.functions.SampleFlux;
import org.influxdata.flux.functions.SetFlux;
import org.influxdata.flux.functions.ShiftFlux;
import org.influxdata.flux.functions.SkewFlux;
import org.influxdata.flux.functions.SortFlux;
import org.influxdata.flux.functions.SpreadFlux;
import org.influxdata.flux.functions.StddevFlux;
import org.influxdata.flux.functions.SumFlux;
import org.influxdata.flux.functions.ToBoolFlux;
import org.influxdata.flux.functions.ToDurationFlux;
import org.influxdata.flux.functions.ToFloatFlux;
import org.influxdata.flux.functions.ToFlux;
import org.influxdata.flux.functions.ToIntFlux;
import org.influxdata.flux.functions.ToStringFlux;
import org.influxdata.flux.functions.ToTimeFlux;
import org.influxdata.flux.functions.ToUIntFlux;
import org.influxdata.flux.functions.WindowFlux;
import org.influxdata.flux.functions.YieldFlux;
import org.influxdata.flux.functions.properties.FunctionsParameters;
import org.influxdata.flux.functions.restriction.Restrictions;
import org.influxdata.platform.Arguments;

/**
 * &lt;a href=&quot;http://bit.ly/flux-spec#basic-syntax&quot;&gt;Flux&lt;/a&gt; - Data Scripting Language.
 * &lt;br&gt;
 * &lt;a href=&quot;http://bit.ly/flux-spec&quot;&gt;Flux Specification&lt;/a&gt;
 * &lt;p&gt;
 * TODO integration tests.
 *
 * &lt;h3&gt;The functions:&lt;/h3&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link FromFlux}&lt;/li&gt;
 * &lt;li&gt;!TODO Buckets&lt;/li&gt;
 * &lt;li&gt;{@link CountFlux}&lt;/li&gt;
 * &lt;li&gt;{@link CovarianceFlux}&lt;/li&gt;
 * &lt;li&gt;{@link CumulativeSumFlux}&lt;/li&gt;
 * &lt;li&gt;{@link DerivativeFlux}&lt;/li&gt;
 * &lt;li&gt;{@link DifferenceFlux}&lt;/li&gt;
 * &lt;li&gt;{@link DistinctFlux}&lt;/li&gt;
 * &lt;li&gt;{@link DropFlux}&lt;/li&gt;
 * &lt;li&gt;{@link DuplicateFlux}&lt;/li&gt;
 * &lt;li&gt;{@link FilterFlux}&lt;/li&gt;
 * &lt;li&gt;{@link FirstFlux}&lt;/li&gt;
 * &lt;li&gt;{@link GroupFlux}&lt;/li&gt;
 * &lt;li&gt;!TODO - histogram&lt;/li&gt;
 * &lt;li&gt;!TODO - histogramQuantile&lt;/li&gt;
 * &lt;li&gt;{@link IntegralFlux}&lt;/li&gt;
 * &lt;li&gt;{@link JoinFlux}&lt;/li&gt;
 * &lt;li&gt;{@link KeepFlux}&lt;/li&gt;
 * &lt;li&gt;{@link LastFlux}&lt;/li&gt;
 * &lt;li&gt;{@link LimitFlux}&lt;/li&gt;
 * &lt;li&gt;!TODO - LinearBuckets&lt;/li&gt;
 * &lt;li&gt;TODO - LogrithmicBuckets&lt;/li&gt;
 * &lt;li&gt;{@link MapFlux}&lt;/li&gt;
 * &lt;li&gt;{@link MaxFlux}&lt;/li&gt;
 * &lt;li&gt;{@link MeanFlux}&lt;/li&gt;
 * &lt;li&gt;{@link MinFlux}&lt;/li&gt;
 * &lt;li&gt;{@link PercentileFlux}&lt;/li&gt;
 * &lt;li&gt;{@link PivotFlux}&lt;/li&gt;
 * &lt;li&gt;{@link RangeFlux}&lt;/li&gt;
 * &lt;li&gt;{@link RenameFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SampleFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SetFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ShiftFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SkewFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SortFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SpreadFlux}&lt;/li&gt;
 * &lt;li&gt;!TODO stateTracking - Not defined in documentation or SPEC&lt;/li&gt;
 * &lt;li&gt;{@link StddevFlux}&lt;/li&gt;
 * &lt;li&gt;{@link SumFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToBoolFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToIntFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToFloatFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToDurationFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToStringFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToTimeFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ToUIntFlux}&lt;/li&gt;
 * &lt;li&gt;{@link WindowFlux}&lt;/li&gt;
 * &lt;li&gt;{@link YieldFlux}&lt;/li&gt;
 * &lt;li&gt;{@link ExpressionFlux}&lt;/li&gt;
 * &lt;li&gt;TODO - toKafka, toHttp&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Jakub Bednar (bednar@github) (22/06/2018 10:16)
 */
@SuppressWarnings({&quot;FileLength&quot;})
<span class="fc" id="L146">public abstract class Flux {</span>

<span class="fc" id="L148">    protected FunctionsParameters functionsParameters = FunctionsParameters.of();</span>

    /**
     * Get data from the specified database.
     *
     * @param bucket Bucket name
     * @return {@link FromFlux}
     */
    @Nonnull
    public static Flux from(@Nonnull final String bucket) {
<span class="fc" id="L158">        Arguments.checkNonEmpty(bucket, &quot;Bucket name&quot;);</span>

<span class="fc" id="L160">        return new FromFlux().withPropertyValueEscaped(&quot;bucket&quot;, bucket);</span>
    }

    /**
     * Get data from the specified database.
     *
     * @param bucket Bucket name
     * @param hosts  the Fluxd hosts
     * @return {@link FromFlux}
     */
    @Nonnull
    public static Flux from(@Nonnull final String bucket, @Nonnull final Collection&lt;String&gt; hosts) {
<span class="fc" id="L172">        Arguments.checkNonEmpty(bucket, &quot;Bucket name&quot;);</span>
<span class="fc" id="L173">        Arguments.checkNotNull(hosts, &quot;Hosts are required&quot;);</span>

<span class="fc" id="L175">        return new FromFlux()</span>
<span class="fc" id="L176">                .withPropertyValueEscaped(&quot;bucket&quot;, bucket)</span>
<span class="fc" id="L177">                .withPropertyValue(&quot;hosts&quot;, hosts);</span>
    }

    /**
     * Get data from the specified database.
     *
     * @param bucket Bucket name
     * @param hosts  the Fluxd hosts
     * @return {@link FromFlux}
     */
    @Nonnull
    public static Flux from(@Nonnull final String bucket, @Nonnull final String[] hosts) {
<span class="fc" id="L189">        Arguments.checkNonEmpty(bucket, &quot;Database name&quot;);</span>
<span class="fc" id="L190">        Arguments.checkNotNull(hosts, &quot;Hosts are required&quot;);</span>

<span class="fc" id="L192">        return new FromFlux()</span>
<span class="fc" id="L193">                .withPropertyValueEscaped(&quot;bucket&quot;, bucket)</span>
<span class="fc" id="L194">                .withPropertyValue(&quot;hosts&quot;, hosts);</span>
    }

    /**
     * Join two time series together on time and the list of tags.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link JoinFlux#withTable(String, Flux)}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withOn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withOn(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withOn(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withMethod(String)}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link JoinFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link JoinFlux}
     */
    @Nonnull
    public static JoinFlux join() {

<span class="nc" id="L216">        return new JoinFlux();</span>
    }

    /**
     * Join two time series together on time and the list of tags.
     *
     * @param name1  table 1 name
     * @param table1 table 1 Flux script
     * @param name2  table 2 name
     * @param table2 table 2 Flux script
     * @param tag    tag key to join
     * @param method the type of join to be performed
     * @return {@link JoinFlux}
     */
    @Nonnull
    public static JoinFlux join(@Nonnull final String name1,
                                @Nonnull final Flux table1,
                                @Nonnull final String name2,
                                @Nonnull final Flux table2,
                                @Nonnull final String tag,
                                @Nonnull final String method) {

<span class="nc" id="L238">        return new JoinFlux()</span>
<span class="nc" id="L239">                .withTable(name1, table1)</span>
<span class="nc" id="L240">                .withTable(name2, table2)</span>
<span class="nc" id="L241">                .withOn(tag)</span>
<span class="nc" id="L242">                .withMethod(method);</span>
    }

    /**
     * It will return a table containing only columns that are specified.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link KeepFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link KeepFlux#withFunction(String)}&lt;/li&gt;
     * &lt;li&gt;{@link KeepFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link KeepFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link KeepFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link KeepFlux}
     */
    @Nonnull
    public final KeepFlux keep() {
<span class="fc" id="L261">        return new KeepFlux(this);</span>
    }

    /**
     * It will return a table containing only columns that are specified.
     *
     * @param columns The list of columns that should be included in the resulting table.
     * @return {@link KeepFlux}
     */
    @Nonnull
    public final KeepFlux keep(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L272">        return new KeepFlux(this).withColumns(columns);</span>
    }

    /**
     * It will return a table containing only columns that are specified.
     *
     * @param columns The list of columns that should be included in the resulting table.
     * @return {@link DropFlux}
     */
    @Nonnull
    public final KeepFlux keep(@Nonnull final String[] columns) {
<span class="fc" id="L283">        return new KeepFlux(this).withColumns(columns);</span>
    }

    /**
     * It will return a table containing only columns that are specified.
     *
     * @param function The function which takes a column name as a parameter and returns a boolean indicating whether
     *                 or not the column should be included in the resulting table.
     * @return {@link DropFlux}
     */
    @Nonnull
    public final KeepFlux keep(@Nonnull final String function) {
<span class="fc" id="L295">        return new KeepFlux(this).withFunction(function);</span>
    }

    /**
     * Counts the number of results.
     *
     * @return {@link CountFlux}
     */
    @Nonnull
    public final CountFlux count() {
<span class="fc" id="L305">        return new CountFlux(this);</span>
    }

    /**
     * Counts the number of results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link CountFlux}
     */
    @Nonnull
    public final CountFlux count(final boolean useStartTime) {
<span class="fc" id="L316">        return new CountFlux(this)</span>
<span class="fc" id="L317">                .withUseStartTime(useStartTime);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link CovarianceFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withColumns(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withPearsonr(boolean)}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withValueDst(String)}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link CovarianceFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance() {
<span class="fc" id="L338">        return new CovarianceFlux(this);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L349">        return new CovarianceFlux(this).withColumns(columns);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final String[] columns) {
<span class="fc" id="L360">        return new CovarianceFlux(this).withColumns(columns);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param pearsonr indicates whether the result should be normalized to be the Pearson R coefficient
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final Collection&lt;String&gt; columns, final boolean pearsonr) {
<span class="fc" id="L372">        return new CovarianceFlux(this).withColumns(columns).withPearsonr(pearsonr);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param pearsonr indicates whether the result should be normalized to be the Pearson R coefficient
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final String[] columns, final boolean pearsonr) {
<span class="fc" id="L384">        return new CovarianceFlux(this).withColumns(columns).withPearsonr(pearsonr);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param valueDst column into which the result will be placed.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final Collection&lt;String&gt; columns,
                                           @Nonnull final String valueDst) {
<span class="fc" id="L397">        return new CovarianceFlux(this).withColumns(columns).withValueDst(valueDst);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param valueDst column into which the result will be placed.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final String[] columns,
                                           @Nonnull final String valueDst) {
<span class="fc" id="L410">        return new CovarianceFlux(this).withColumns(columns).withValueDst(valueDst);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param pearsonr indicates whether the result should be normalized to be the Pearson R coefficient
     * @param valueDst column into which the result will be placed.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final Collection&lt;String&gt; columns,
                                           final boolean pearsonr,
                                           @Nonnull final String valueDst) {
<span class="fc" id="L425">        return new CovarianceFlux(this).withColumns(columns).withPearsonr(pearsonr).withValueDst(valueDst);</span>
    }

    /**
     * Covariance computes the covariance between two columns.
     *
     * @param columns  list of columns on which to compute the covariance. Exactly two columns must be provided.
     * @param pearsonr indicates whether the result should be normalized to be the Pearson R coefficient
     * @param valueDst column into which the result will be placed.
     * @return {@link CovarianceFlux}
     */
    @Nonnull
    public final CovarianceFlux covariance(@Nonnull final String[] columns,
                                           final boolean pearsonr,
                                           @Nonnull final String valueDst) {
<span class="fc" id="L440">        return new CovarianceFlux(this).withColumns(columns).withPearsonr(pearsonr).withValueDst(valueDst);</span>
    }

    /**
     * Computes a running sum for non null records in the table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link CumulativeSumFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link CumulativeSumFlux#withColumns(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link CumulativeSumFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link CumulativeSumFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link CumulativeSumFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link CumulativeSumFlux}
     */
    @Nonnull
    public final CumulativeSumFlux cumulativeSum() {
<span class="fc" id="L459">        return new CumulativeSumFlux(this);</span>
    }

    /**
     * Computes a running sum for non null records in the table.
     *
     * @param columns the columns on which to operate
     * @return {@link CumulativeSumFlux}
     */
    @Nonnull
    public final CumulativeSumFlux cumulativeSum(@Nonnull final String[] columns) {
<span class="fc" id="L470">        return new CumulativeSumFlux(this).withColumns(columns);</span>
    }

    /**
     * Computes a running sum for non null records in the table.
     *
     * @param columns the columns on which to operate
     * @return {@link CumulativeSumFlux}
     */
    @Nonnull
    public final CumulativeSumFlux cumulativeSum(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L481">        return new CumulativeSumFlux(this).withColumns(columns);</span>
    }

    /**
     * Computes the time based difference between subsequent non null records.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DerivativeFlux#withUnit(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withNonNegative(boolean)}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withTimeColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DerivativeFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link DerivativeFlux}
     */
    @Nonnull
    public final DerivativeFlux derivative() {
<span class="fc" id="L502">        return new DerivativeFlux(this);</span>
    }

    /**
     * Computes the time based difference between subsequent non null records.
     *
     * @param duration the time duration to use for the result
     * @param unit     a {@code ChronoUnit} determining how to interpret the {@code duration} parameter
     * @return {@link DerivativeFlux}
     */
    @Nonnull
    public final DerivativeFlux derivative(@Nonnull final Long duration, @Nonnull final ChronoUnit unit) {
<span class="fc" id="L514">        return new DerivativeFlux(this).withUnit(duration, unit);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DifferenceFlux#withNonNegative(boolean)}&lt;/li&gt;
     * &lt;li&gt;{@link DifferenceFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link DifferenceFlux#withColumns(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link DifferenceFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DifferenceFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DifferenceFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference() {
<span class="fc" id="L534">        return new DifferenceFlux(this);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * @param nonNegative indicates if the derivative is allowed to be negative
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference(final boolean nonNegative) {
<span class="fc" id="L545">        return new DifferenceFlux(this).withNonNegative(nonNegative);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * @param columns list of columns on which to compute the difference
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L556">        return new DifferenceFlux(this).withColumns(columns);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * @param columns list of columns on which to compute the difference
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference(@Nonnull final String[] columns) {
<span class="fc" id="L567">        return new DifferenceFlux(this).withColumns(columns);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * @param nonNegative indicates if the derivative is allowed to be negative
     * @param columns     list of columns on which to compute the difference
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference(@Nonnull final Collection&lt;String&gt; columns, final boolean nonNegative) {
<span class="fc" id="L579">        return new DifferenceFlux(this).withColumns(columns).withNonNegative(nonNegative);</span>
    }

    /**
     * Difference computes the difference between subsequent non null records.
     *
     * @param nonNegative indicates if the derivative is allowed to be negative
     * @param columns     list of columns on which to compute the difference
     * @return {@link DifferenceFlux}
     */
    @Nonnull
    public final DifferenceFlux difference(@Nonnull final String[] columns, final boolean nonNegative) {
<span class="fc" id="L591">        return new DifferenceFlux(this).withColumns(columns).withNonNegative(nonNegative);</span>
    }

    /**
     * Distinct produces the unique values for a given column.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DistinctFlux#withColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DistinctFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DistinctFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DistinctFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link DistinctFlux}
     */
    @Nonnull
    public final DistinctFlux distinct() {
<span class="fc" id="L609">        return new DistinctFlux(this);</span>
    }

    /**
     * Distinct produces the unique values for a given column.
     *
     * @param column The column on which to track unique values.
     * @return {@link DistinctFlux}
     */
    @Nonnull
    public final DistinctFlux distinct(@Nonnull final String column) {
<span class="fc" id="L620">        return new DistinctFlux(this).withColumn(column);</span>
    }

    /**
     * Drop will exclude specified columns from a table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DropFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link DropFlux#withFunction(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DropFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DropFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DropFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link DropFlux}
     */
    @Nonnull
    public final DropFlux drop() {
<span class="fc" id="L639">        return new DropFlux(this);</span>
    }

    /**
     * Drop will exclude specified columns from a table.
     *
     * @param columns The list of columns which should be excluded from the resulting table.
     * @return {@link DropFlux}
     */
    @Nonnull
    public final DropFlux drop(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L650">        return new DropFlux(this).withColumns(columns);</span>
    }

    /**
     * Drop will exclude specified columns from a table.
     *
     * @param columns The list of columns which should be excluded from the resulting table.
     * @return {@link DropFlux}
     */
    @Nonnull
    public final DropFlux drop(@Nonnull final String[] columns) {
<span class="fc" id="L661">        return new DropFlux(this).withColumns(columns);</span>
    }

    /**
     * Drop will exclude specified columns from a table.
     *
     * @param function The function which takes a column name as a parameter and returns a boolean indicating whether
     *                 or not the column should be excluded from the resulting table.
     * @return {@link DropFlux}
     */
    @Nonnull
    public final DropFlux drop(@Nonnull final String function) {
<span class="fc" id="L673">        return new DropFlux(this).withFunction(function);</span>
    }

    /**
     * Duplicate will duplicate a specified column in a table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DuplicateFlux#withAs(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withColumn(String)} (String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link DuplicateFlux}
     */
    @Nonnull
    public final DuplicateFlux duplicate() {
<span class="fc" id="L692">        return new DuplicateFlux(this);</span>
    }

    /**
     * Duplicate will duplicate a specified column in a table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link DuplicateFlux#withAs(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withColumn(String)} (String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link DuplicateFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param column the column to duplicate
     * @param as     the name that should be assigned to the duplicate column
     * @return {@link DuplicateFlux}
     */
    @Nonnull
    public final DuplicateFlux duplicate(@Nonnull final String column, @Nonnull final String as) {
<span class="fc" id="L713">        return new DuplicateFlux(this).withColumn(column).withAs(as);</span>
    }

    /**
     * Returns the first result of the query.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link FilterFlux#withRestrictions(Restrictions)}&lt;/li&gt;
     * &lt;li&gt;{@link FilterFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link FilterFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link FilterFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link FilterFlux}
     */
    @Nonnull
    public final FilterFlux filter() {
<span class="nc" id="L731">        return new FilterFlux(this);</span>
    }

    /**
     * Returns the first result of the query.
     *
     * @param restrictions filter restrictions
     * @return {@link FilterFlux}
     */
    @Nonnull
    public final FilterFlux filter(@Nonnull final Restrictions restrictions) {

<span class="fc" id="L743">        Arguments.checkNotNull(restrictions, &quot;Restrictions are required&quot;);</span>

<span class="fc" id="L745">        return new FilterFlux(this).withRestrictions(restrictions);</span>
    }

    /**
     * Returns the first result of the query.
     *
     * @return {@link FirstFlux}
     */
    @Nonnull
    public final FirstFlux first() {
<span class="fc" id="L755">        return new FirstFlux(this);</span>
    }

    /**
     * Returns the first result of the query.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link FirstFlux}
     */
    @Nonnull
    public final FirstFlux first(final boolean useStartTime) {
<span class="fc" id="L766">        return new FirstFlux(this)</span>
<span class="fc" id="L767">                .withUseStartTime(useStartTime);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link GroupFlux#withBy(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withBy(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withKeep(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withKeep(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withExcept(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withExcept(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link GroupFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux group() {

<span class="fc" id="L791">        return new GroupFlux(this);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param groupBy Group by these specific tag name.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupBy(@Nonnull final String groupBy) {
<span class="fc" id="L802">        Arguments.checkNotNull(groupBy, &quot;GroupBy Columns are required&quot;);</span>

<span class="fc" id="L804">        return new GroupFlux(this).withBy(groupBy);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param groupBy Group by these specific tag names.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupBy(@Nonnull final Collection&lt;String&gt; groupBy) {
<span class="fc" id="L815">        Arguments.checkNotNull(groupBy, &quot;GroupBy Columns are required&quot;);</span>

<span class="fc" id="L817">        return new GroupFlux(this).withBy(groupBy);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param groupBy Group by these specific tag names.
     * @param keep    Keep specific tag keys that were not in {@code groupBy} in the results.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupBy(@Nonnull final Collection&lt;String&gt; groupBy, @Nonnull final Collection&lt;String&gt; keep) {
<span class="fc" id="L829">        Arguments.checkNotNull(groupBy, &quot;GroupBy Columns are required&quot;);</span>
<span class="fc" id="L830">        Arguments.checkNotNull(keep, &quot;Keep Columns are required&quot;);</span>

<span class="fc" id="L832">        return new GroupFlux(this).withBy(groupBy).withKeep(keep);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param groupBy Group by these specific tag names.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupBy(@Nonnull final String[] groupBy) {
<span class="fc" id="L843">        Arguments.checkNotNull(groupBy, &quot;GroupBy Columns are required&quot;);</span>

<span class="fc" id="L845">        return new GroupFlux(this).withBy(groupBy);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param groupBy Group by these specific tag names.
     * @param keep    Keep specific tag keys that were not in {@code groupBy} in the results.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupBy(@Nonnull final String[] groupBy, @Nonnull final String[] keep) {
<span class="fc" id="L857">        Arguments.checkNotNull(groupBy, &quot;GroupBy Columns are required&quot;);</span>
<span class="fc" id="L858">        Arguments.checkNotNull(keep, &quot;Keep Columns are required&quot;);</span>

<span class="fc" id="L860">        return new GroupFlux(this).withBy(groupBy).withKeep(keep);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param except Group by all but these tag keys Cannot be used.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupExcept(@Nonnull final Collection&lt;String&gt; except) {
<span class="fc" id="L871">        Arguments.checkNotNull(except, &quot;GroupBy Except Columns are required&quot;);</span>

<span class="fc" id="L873">        return new GroupFlux(this).withExcept(except);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param except Group by all but these tag keys Cannot be used.
     * @param keep   Keep specific tag keys that were not in {@code groupBy} in the results.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupExcept(@Nonnull final Collection&lt;String&gt; except,
                                       @Nonnull final Collection&lt;String&gt; keep) {

<span class="fc" id="L887">        Arguments.checkNotNull(except, &quot;GroupBy Except Columns are required&quot;);</span>
<span class="fc" id="L888">        Arguments.checkNotNull(keep, &quot;Keep Columns are required&quot;);</span>

<span class="fc" id="L890">        return new GroupFlux(this).withExcept(except).withKeep(keep);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param except Group by all but these tag keys Cannot be used.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupExcept(@Nonnull final String[] except) {
<span class="fc" id="L901">        Arguments.checkNotNull(except, &quot;GroupBy Except Columns are required&quot;);</span>

<span class="fc" id="L903">        return new GroupFlux(this).withExcept(except);</span>
    }

    /**
     * Groups results by a user-specified set of tags.
     *
     * @param except Group by all but these tag keys Cannot be used.
     * @param keep   Keep specific tag keys that were not in {@code groupBy} in the results.
     * @return {@link GroupFlux}
     */
    @Nonnull
    public final GroupFlux groupExcept(@Nonnull final String[] except, @Nonnull final String[] keep) {
<span class="fc" id="L915">        Arguments.checkNotNull(except, &quot;GroupBy Except Columns are required&quot;);</span>
<span class="fc" id="L916">        Arguments.checkNotNull(keep, &quot;Keep Columns are required&quot;);</span>

<span class="fc" id="L918">        return new GroupFlux(this).withExcept(except).withKeep(keep);</span>
    }

    /**
     * For each aggregate column, it outputs the area under the curve of non null records.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link IntegralFlux#withUnit(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link IntegralFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link IntegralFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link IntegralFlux}
     */
    @Nonnull
    public final IntegralFlux integral() {

<span class="fc" id="L936">        return new IntegralFlux(this);</span>
    }

    /**
     * For each aggregate column, it outputs the area under the curve of non null records.
     *
     * @param duration Time duration to use when computing the integral
     * @param unit     a {@code ChronoUnit} determining how to interpret the {@code duration} parameter
     * @return {@link IntegralFlux}
     */
    @Nonnull
    public final IntegralFlux integral(@Nonnull final Long duration, @Nonnull final ChronoUnit unit) {

<span class="fc" id="L949">        Arguments.checkNotNull(duration, &quot;Duration is required&quot;);</span>
<span class="fc" id="L950">        Arguments.checkNotNull(unit, &quot;ChronoUnit is required&quot;);</span>

<span class="fc" id="L952">        return new IntegralFlux(this).withUnit(duration, unit);</span>
    }

    /**
     * Returns the last result of the query.
     *
     * @return {@link LastFlux}
     */
    @Nonnull
    public final LastFlux last() {
<span class="fc" id="L962">        return new LastFlux(this);</span>
    }

    /**
     * Returns the last result of the query.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link LastFlux}
     */
    @Nonnull
    public final LastFlux last(final boolean useStartTime) {
<span class="fc" id="L973">        return new LastFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Restricts the number of rows returned in the results.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link LimitFlux#withN(int)}&lt;/li&gt;
     * &lt;li&gt;{@link LimitFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link LimitFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link LimitFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link LimitFlux}
     */
    @Nonnull
    public final LimitFlux limit() {

<span class="fc" id="L992">        return new LimitFlux(this);</span>
    }

    /**
     * Restricts the number of rows returned in the results.
     *
     * @param numberOfResults The number of results
     * @return {@link LimitFlux}
     */
    @Nonnull
    public final LimitFlux limit(final int numberOfResults) {

<span class="fc" id="L1004">        return new LimitFlux(this).withN(numberOfResults);</span>
    }

    /**
     * Applies a function to each row of the table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link MapFlux#withFunction(String)}&lt;/li&gt;
     * &lt;li&gt;{@link MapFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link MapFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link MapFlux}
     */
    @Nonnull
    public final MapFlux map() {

<span class="fc" id="L1022">        return new MapFlux(this);</span>
    }

    /**
     * Applies a function to each row of the table.
     *
     * @param function The function for map row of table. Example: &quot;r._value * r._value&quot;.
     * @return {@link MapFlux}
     */
    @Nonnull
    public final MapFlux map(@Nonnull final String function) {

<span class="fc" id="L1034">        return new MapFlux(this).withFunction(function);</span>
    }

    /**
     * Returns the max value within the results.
     *
     * @return {@link MaxFlux}
     */
    @Nonnull
    public final MaxFlux max() {
<span class="fc" id="L1044">        return new MaxFlux(this);</span>
    }

    /**
     * Returns the max value within the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link MaxFlux}
     */
    @Nonnull
    public final MaxFlux max(final boolean useStartTime) {
<span class="fc" id="L1055">        return new MaxFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Returns the mean of the values within the results.
     *
     * @return {@link MeanFlux}
     */
    @Nonnull
    public final MeanFlux mean() {
<span class="fc" id="L1065">        return new MeanFlux(this);</span>
    }

    /**
     * Returns the mean of the values within the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link MeanFlux}
     */
    @Nonnull
    public final MeanFlux mean(final boolean useStartTime) {
<span class="fc" id="L1076">        return new MeanFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Returns the min value within the results.
     *
     * @return {@link MinFlux}
     */
    @Nonnull
    public final MinFlux min() {
<span class="fc" id="L1086">        return new MinFlux(this);</span>
    }

    /**
     * Returns the min value within the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link MinFlux}
     */
    @Nonnull
    public final MinFlux min(final boolean useStartTime) {
<span class="fc" id="L1097">        return new MinFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link PercentileFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withColumns(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withPercentile(Float)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withCompression(Float)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withMethod(String)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withMethod(PercentileFlux.MethodType)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withFunction(String, Object)}&lt;/li&gt;
     * &lt;li&gt;{@link PercentileFlux#withFunctionNamed(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile() {
<span class="fc" id="L1122">        return new PercentileFlux(this);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * @param percentile value between 0 and 1 indicating the desired percentile
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile(@Nonnull final Float percentile) {

<span class="fc" id="L1134">        return new PercentileFlux(this)</span>
<span class="fc" id="L1135">                .withPercentile(percentile);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * @param percentile value between 0 and 1 indicating the desired percentile
     * @param method     method to aggregate
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile(@Nonnull final Float percentile,
                                           @Nonnull final PercentileFlux.MethodType method) {

<span class="fc" id="L1149">        return new PercentileFlux(this)</span>
<span class="fc" id="L1150">                .withPercentile(percentile)</span>
<span class="fc" id="L1151">                .withMethod(method);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * @param percentile  value between 0 and 1 indicating the desired percentile
     * @param method      method to aggregate
     * @param compression indicates how many centroids to use when compressing the dataset
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile(@Nonnull final Float percentile,
                                           @Nonnull final PercentileFlux.MethodType method,
                                           @Nonnull final Float compression) {

<span class="fc" id="L1167">        return new PercentileFlux(this)</span>
<span class="fc" id="L1168">                .withPercentile(percentile)</span>
<span class="fc" id="L1169">                .withMethod(method)</span>
<span class="fc" id="L1170">                .withCompression(compression);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * @param columns     specifies a list of columns to aggregate
     * @param percentile  value between 0 and 1 indicating the desired percentile
     * @param method      method to aggregate
     * @param compression indicates how many centroids to use when compressing the dataset.
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile(@Nonnull final String[] columns,
                                           @Nonnull final Float percentile,
                                           @Nonnull final PercentileFlux.MethodType method,
                                           @Nonnull final Float compression) {

<span class="fc" id="L1188">        return new PercentileFlux(this)</span>
<span class="fc" id="L1189">                .withColumns(columns)</span>
<span class="fc" id="L1190">                .withPercentile(percentile)</span>
<span class="fc" id="L1191">                .withMethod(method)</span>
<span class="fc" id="L1192">                .withCompression(compression);</span>
    }

    /**
     * Percentile is both an aggregate operation and a selector operation depending on selected options.
     *
     * @param columns     specifies a list of columns to aggregate
     * @param percentile  value between 0 and 1 indicating the desired percentile
     * @param method      method to aggregate
     * @param compression indicates how many centroids to use when compressing the dataset.
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PercentileFlux percentile(@Nonnull final Collection&lt;String&gt; columns,
                                           @Nonnull final Float percentile,
                                           @Nonnull final PercentileFlux.MethodType method,
                                           @Nonnull final Float compression) {

<span class="fc" id="L1210">        return new PercentileFlux(this)</span>
<span class="fc" id="L1211">                .withColumns(columns)</span>
<span class="fc" id="L1212">                .withPercentile(percentile)</span>
<span class="fc" id="L1213">                .withMethod(method)</span>
<span class="fc" id="L1214">                .withCompression(compression);</span>
    }

    /**
     * Pivot collects values stored vertically (column-wise) in a table
     * and aligns them horizontally (row-wise) into logical sets.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link PivotFlux#withRowKey(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withRowKey(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withColumnKey(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withColumnKey(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withValueColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link PivotFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PivotFlux pivot() {
<span class="fc" id="L1237">        return new PivotFlux(this);</span>
    }

    /**
     * Pivot collects values stored vertically (column-wise) in a table
     * and aligns them horizontally (row-wise) into logical sets.
     *
     * @param rowKey      the columns used to uniquely identify a row for the output
     * @param columnKey   the columns used to pivot values onto each row identified by the rowKey.
     * @param valueColumn the single column that contains the value to be moved around the pivot
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PivotFlux pivot(@Nonnull final String[] rowKey,
                                 @Nonnull final String[] columnKey,
                                 @Nonnull final String valueColumn) {

<span class="fc" id="L1254">        return new PivotFlux(this).withRowKey(rowKey).withColumnKey(columnKey).withValueColumn(valueColumn);</span>
    }

    /**
     * Pivot collects values stored vertically (column-wise) in a table
     * and aligns them horizontally (row-wise) into logical sets.
     *
     * @param rowKey      the columns used to uniquely identify a row for the output
     * @param columnKey   the columns used to pivot values onto each row identified by the rowKey.
     * @param valueColumn the single column that contains the value to be moved around the pivot
     * @return {@link PivotFlux}
     */
    @Nonnull
    public final PivotFlux pivot(@Nonnull final Collection&lt;String&gt; rowKey,
                                 @Nonnull final Collection&lt;String&gt; columnKey,
                                 @Nonnull final String valueColumn) {

<span class="fc" id="L1271">        return new PivotFlux(this).withRowKey(rowKey).withColumnKey(columnKey).withValueColumn(valueColumn);</span>
    }

    /**
     * Filters the results by time boundaries.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link RangeFlux#withStart(Instant)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withStart(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withStop(Instant)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withStop(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link RangeFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link RangeFlux}
     */
    @Nonnull
    public final RangeFlux range() {

<span class="fc" id="L1293">        return new RangeFlux(this);</span>
    }

    /**
     * Filters the results by time boundaries.
     *
     * @param start Specifies the oldest time to be included in the results
     * @return {@link RangeFlux}
     */
    @Nonnull
    public final RangeFlux range(@Nonnull final Instant start) {
<span class="fc" id="L1304">        Arguments.checkNotNull(start, &quot;Start is required&quot;);</span>

<span class="fc" id="L1306">        return new RangeFlux(this).withStart(start);</span>
    }

    /**
     * Filters the results by time boundaries.
     *
     * @param start Specifies the oldest time to be included in the results
     * @param stop  Specifies the exclusive newest time to be included in the results
     * @return {@link RangeFlux}
     */
    @Nonnull
    public final RangeFlux range(@Nonnull final Instant start, @Nonnull final Instant stop) {
<span class="fc" id="L1318">        Arguments.checkNotNull(start, &quot;Start is required&quot;);</span>
<span class="fc" id="L1319">        Arguments.checkNotNull(stop, &quot;Stop is required&quot;);</span>

<span class="fc" id="L1321">        return new RangeFlux(this).withStart(start).withStop(stop);</span>
    }

    /**
     * Filters the results by time boundaries.
     *
     * @param start Specifies the oldest time to be included in the results
     * @param unit  a {@code ChronoUnit} determining how to interpret the {@code start} parameter
     * @return {@link RangeFlux}
     */
    @Nonnull
    public final RangeFlux range(@Nonnull final Long start, @Nonnull final ChronoUnit unit) {
<span class="fc" id="L1333">        Arguments.checkNotNull(start, &quot;Start is required&quot;);</span>
<span class="fc" id="L1334">        Arguments.checkNotNull(unit, &quot;ChronoUnit is required&quot;);</span>

<span class="fc" id="L1336">        return new RangeFlux(this).withStart(start, unit);</span>
    }

    /**
     * Filters the results by time boundaries.
     *
     * @param start Specifies the oldest time to be included in the results
     * @param stop  Specifies the exclusive newest time to be included in the results
     * @param unit  a {@code ChronoUnit} determining how to interpret the {@code start} and {@code stop} parameter
     * @return {@link RangeFlux}
     */
    @Nonnull
    public final RangeFlux range(@Nonnull final Long start, @Nonnull final Long stop, @Nonnull final ChronoUnit unit) {
<span class="fc" id="L1349">        Arguments.checkNotNull(start, &quot;Start is required&quot;);</span>
<span class="fc" id="L1350">        Arguments.checkNotNull(stop, &quot;Stop is required&quot;);</span>
<span class="fc" id="L1351">        Arguments.checkNotNull(unit, &quot;ChronoUnit is required&quot;);</span>

<span class="fc" id="L1353">        return new RangeFlux(this).withStart(start, unit).withStop(stop, unit);</span>
    }

    /**
     * Rename will rename specified columns in a table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link RenameFlux#withColumns(Map)} &lt;/li&gt;
     * &lt;li&gt;{@link RenameFlux#withFunction(String)}&lt;/li&gt;
     * &lt;li&gt;{@link RenameFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link RenameFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link RenameFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link RenameFlux}
     */
    @Nonnull
    public final RenameFlux rename() {
<span class="fc" id="L1372">        return new RenameFlux(this);</span>
    }

    /**
     * Rename will rename specified columns in a table.
     *
     * @param columns The map of columns to rename and their corresponding new names.
     * @return {@link RenameFlux}
     */
    @Nonnull
    public final RenameFlux rename(@Nonnull final Map&lt;String, String&gt; columns) {
<span class="fc" id="L1383">        return new RenameFlux(this).withColumns(columns);</span>
    }

    /**
     * Rename will rename specified columns in a table.
     *
     * @param function The function which takes a single string parameter (the old column name) and
     *                 returns a string representing the new column name.
     * @return {@link RenameFlux}
     */
    @Nonnull
    public final RenameFlux rename(@Nonnull final String function) {
<span class="fc" id="L1395">        return new RenameFlux(this).withFunction(function);</span>
    }

    /**
     * Sample values from a table.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link SampleFlux#withN(int)}&lt;/li&gt;
     * &lt;li&gt;{@link SampleFlux#withPos(int)}&lt;/li&gt;
     * &lt;li&gt;{@link SampleFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link SampleFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link SampleFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link SampleFlux}
     */
    @Nonnull
    public final SampleFlux sample() {

<span class="fc" id="L1415">        return new SampleFlux(this);</span>
    }

    /**
     * Sample values from a table.
     *
     * @param n Sample every Nth element.
     * @return {@link SampleFlux}
     */
    @Nonnull
    public final SampleFlux sample(final int n) {

<span class="fc" id="L1427">        return new SampleFlux(this)</span>
<span class="fc" id="L1428">                .withN(n);</span>
    }

    /**
     * Sample values from a table.
     *
     * @param n   Sample every Nth element.
     * @param pos Position offset from start of results to begin sampling. Must be less than @{code n}.
     * @return {@link SampleFlux}
     */
    @Nonnull
    public final SampleFlux sample(final int n, final int pos) {

<span class="fc bfc" id="L1441" title="All 2 branches covered.">        if (pos &gt;= n) {</span>
<span class="fc" id="L1442">            throw new IllegalArgumentException(&quot;pos must be less than n&quot;);</span>
        }

<span class="fc" id="L1445">        return new SampleFlux(this)</span>
<span class="fc" id="L1446">                .withN(n)</span>
<span class="fc" id="L1447">                .withPos(pos);</span>
    }

    /**
     * Assigns a static value to each record.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link SetFlux#withKeyValue(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link SetFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link SetFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link SetFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link SetFlux}
     */
    @Nonnull
    public final SetFlux set() {
<span class="fc" id="L1465">        return new SetFlux(this);</span>
    }

    /**
     * Assigns a static value to each record.
     *
     * @param key   label for the column. Has to be defined.
     * @param value value for the column. Has to be defined.
     * @return {@link SetFlux}
     */
    @Nonnull
    public final SetFlux set(@Nonnull final String key, @Nonnull final String value) {
<span class="fc" id="L1477">        return new SetFlux(this).withKeyValue(key, value);</span>
    }

    /**
     * Shift add a fixed duration to time columns.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link ShiftFlux#withShift(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link ShiftFlux#withColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link ShiftFlux#withColumns(Collection)} )}&lt;/li&gt;
     * &lt;li&gt;{@link ShiftFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ShiftFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link ShiftFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link ShiftFlux}
     */
    @Nonnull
    public final ShiftFlux shift() {
<span class="fc" id="L1497">        return new ShiftFlux(this);</span>
    }

    /**
     * Shift add a fixed duration to time columns.
     *
     * @param amount The amount to add to each time value
     * @param unit   a {@code ChronoUnit} determining how to interpret the {@code amount} parameter
     * @return {@link ShiftFlux}
     */
    @Nonnull
    public final ShiftFlux shift(@Nonnull final Long amount,
                                 @Nonnull final ChronoUnit unit) {

<span class="fc" id="L1511">        return new ShiftFlux(this).withShift(amount, unit);</span>
    }

    /**
     * Shift add a fixed duration to time columns.
     *
     * @param amount  The amount to add to each time value
     * @param unit    a {@code ChronoUnit} determining how to interpret the {@code amount} parameter
     * @param columns The list of all columns that should be shifted.
     * @return {@link ShiftFlux}
     */
    @Nonnull
    public final ShiftFlux shift(@Nonnull final Long amount,
                                 @Nonnull final ChronoUnit unit,
                                 @Nonnull final String[] columns) {

<span class="fc" id="L1527">        return new ShiftFlux(this).withShift(amount, unit).withColumns(columns);</span>
    }

    /**
     * Shift add a fixed duration to time columns.
     *
     * @param amount  The amount to add to each time value
     * @param unit    a {@code ChronoUnit} determining how to interpret the {@code amount} parameter
     * @param columns The list of all columns that should be shifted.
     * @return {@link ShiftFlux}
     */
    @Nonnull
    public final ShiftFlux shift(@Nonnull final Long amount,
                                 @Nonnull final ChronoUnit unit,
                                 @Nonnull final Collection&lt;String&gt; columns) {

<span class="fc" id="L1543">        return new ShiftFlux(this).withShift(amount, unit).withColumns(columns);</span>
    }

    /**
     * Skew of the results.
     *
     * @return {@link SkewFlux}
     */
    @Nonnull
    public final SkewFlux skew() {
<span class="fc" id="L1553">        return new SkewFlux(this);</span>
    }

    /**
     * Skew of the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link SkewFlux}
     */
    @Nonnull
    public final SkewFlux skew(final boolean useStartTime) {
<span class="fc" id="L1564">        return new SkewFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort() {
<span class="fc" id="L1574">        return new SortFlux(this);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @param desc use the descending sorting
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort(final boolean desc) {
<span class="fc" id="L1585">        return new SortFlux(this).withDesc(desc);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @param columns columns used to sort
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort(@Nonnull final String[] columns) {
<span class="fc" id="L1596">        Arguments.checkNotNull(columns, &quot;Columns are required&quot;);</span>

<span class="fc" id="L1598">        return new SortFlux(this).withColumns(columns);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @param columns columns used to sort
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort(@Nonnull final Collection&lt;String&gt; columns) {
<span class="fc" id="L1609">        Arguments.checkNotNull(columns, &quot;Columns are required&quot;);</span>

<span class="fc" id="L1611">        return new SortFlux(this).withColumns(columns);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @param columns columns used to sort
     * @param desc    use the descending sorting
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort(@Nonnull final String[] columns, final boolean desc) {
<span class="fc" id="L1623">        Arguments.checkNotNull(columns, &quot;Columns are required&quot;);</span>

<span class="fc" id="L1625">        return new SortFlux(this)</span>
<span class="fc" id="L1626">                .withColumns(columns)</span>
<span class="fc" id="L1627">                .withDesc(desc);</span>
    }

    /**
     * Sorts the results by the specified columns Default sort is ascending.
     *
     * @param columns columns used to sort
     * @param desc    use the descending sorting
     * @return {@link SortFlux}
     */
    @Nonnull
    public final SortFlux sort(@Nonnull final Collection&lt;String&gt; columns, final boolean desc) {
<span class="fc" id="L1639">        Arguments.checkNotNull(columns, &quot;Columns are required&quot;);</span>

<span class="fc" id="L1641">        return new SortFlux(this)</span>
<span class="fc" id="L1642">                .withColumns(columns)</span>
<span class="fc" id="L1643">                .withDesc(desc);</span>
    }

    /**
     * Difference between min and max values.
     *
     * @return {@link SpreadFlux}
     */
    @Nonnull
    public final SpreadFlux spread() {
<span class="fc" id="L1653">        return new SpreadFlux(this);</span>
    }

    /**
     * Difference between min and max values.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link SpreadFlux}
     */
    @Nonnull
    public final SpreadFlux spread(final boolean useStartTime) {
<span class="fc" id="L1664">        return new SpreadFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Standard Deviation of the results.
     *
     * @return {@link StddevFlux}
     */
    @Nonnull
    public final StddevFlux stddev() {
<span class="fc" id="L1674">        return new StddevFlux(this);</span>
    }

    /**
     * Standard Deviation of the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link StddevFlux}
     */
    @Nonnull
    public final StddevFlux stddev(final boolean useStartTime) {
<span class="fc" id="L1685">        return new StddevFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * Sum of the results.
     *
     * @return {@link SumFlux}
     */
    @Nonnull
    public final SumFlux sum() {
<span class="fc" id="L1695">        return new SumFlux(this);</span>
    }

    /**
     * Sum of the results.
     *
     * @param useStartTime Use the start time as the timestamp of the resulting aggregate
     * @return {@link SumFlux}
     */
    @Nonnull
    public final SumFlux sum(final boolean useStartTime) {
<span class="fc" id="L1706">        return new SumFlux(this).withUseStartTime(useStartTime);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link ToFlux#withBucket(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withBucketID(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withOrg(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withOrgID(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withHost(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withToken(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withTimeColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withTagColumns(Collection)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withTagColumns(String[])}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withFieldFunction(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link ToFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to() {
<span class="fc" id="L1733">        return new ToFlux(this);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket The bucket to which data will be written.
     * @param org    The organization name of the above bucket.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org) {

<span class="fc" id="L1747">        return new ToFlux(this)</span>
<span class="fc" id="L1748">                .withBucket(bucket)</span>
<span class="fc" id="L1749">                .withOrg(org);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket  The bucket to which data will be written.
     * @param org     The organization name of the above bucket.
     * @param fieldFn Function that takes a record from the input table and returns an object.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org,
                           @Nonnull final String fieldFn) {

<span class="fc" id="L1765">        return new ToFlux(this)</span>
<span class="fc" id="L1766">                .withBucket(bucket)</span>
<span class="fc" id="L1767">                .withOrg(org)</span>
<span class="fc" id="L1768">                .withFieldFunction(fieldFn);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket     The bucket to which data will be written.
     * @param org        The organization name of the above bucket.
     * @param tagColumns The tag columns of the output.
     * @param fieldFn    Function that takes a record from the input table and returns an object.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org,
                           @Nonnull final String[] tagColumns,
                           @Nonnull final String fieldFn) {

<span class="fc" id="L1786">        return new ToFlux(this)</span>
<span class="fc" id="L1787">                .withBucket(bucket)</span>
<span class="fc" id="L1788">                .withOrg(org)</span>
<span class="fc" id="L1789">                .withTagColumns(tagColumns)</span>
<span class="fc" id="L1790">                .withFieldFunction(fieldFn);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket     The bucket to which data will be written.
     * @param org        The organization name of the above bucket.
     * @param tagColumns The tag columns of the output.
     * @param fieldFn    Function that takes a record from the input table and returns an object.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org,
                           @Nonnull final Collection&lt;String&gt; tagColumns,
                           @Nonnull final String fieldFn) {

<span class="fc" id="L1808">        return new ToFlux(this)</span>
<span class="fc" id="L1809">                .withBucket(bucket)</span>
<span class="fc" id="L1810">                .withOrg(org)</span>
<span class="fc" id="L1811">                .withTagColumns(tagColumns)</span>
<span class="fc" id="L1812">                .withFieldFunction(fieldFn);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket     The bucket to which data will be written.
     * @param org        The organization name of the above bucket.
     * @param host       The remote host to write to.
     * @param token      The authorization token to use when writing to a remote host.
     * @param timeColumn The time column of the output.
     * @param tagColumns The tag columns of the output.
     * @param fieldFn    Function that takes a record from the input table and returns an object.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org,
                           @Nonnull final String host,
                           @Nonnull final String token,
                           @Nonnull final String timeColumn,
                           @Nonnull final String[] tagColumns,
                           @Nonnull final String fieldFn) {

<span class="fc" id="L1836">        return new ToFlux(this)</span>
<span class="fc" id="L1837">                .withBucket(bucket)</span>
<span class="fc" id="L1838">                .withOrg(org)</span>
<span class="fc" id="L1839">                .withHost(host)</span>
<span class="fc" id="L1840">                .withToken(token)</span>
<span class="fc" id="L1841">                .withTimeColumn(timeColumn)</span>
<span class="fc" id="L1842">                .withTagColumns(tagColumns)</span>
<span class="fc" id="L1843">                .withFieldFunction(fieldFn);</span>
    }

    /**
     * To operation takes data from a stream and writes it to a bucket.
     *
     * @param bucket     The bucket to which data will be written.
     * @param org        The organization name of the above bucket.
     * @param host       The remote host to write to.
     * @param token      The authorization token to use when writing to a remote host.
     * @param timeColumn The time column of the output.
     * @param tagColumns The tag columns of the output.
     * @param fieldFn    Function that takes a record from the input table and returns an object.
     * @return {@link ToFlux}
     */
    @Nonnull
    public final ToFlux to(@Nonnull final String bucket,
                           @Nonnull final String org,
                           @Nonnull final String host,
                           @Nonnull final String token,
                           @Nonnull final String timeColumn,
                           @Nonnull final Collection&lt;String&gt; tagColumns,
                           @Nonnull final String fieldFn) {

<span class="fc" id="L1867">        return new ToFlux(this)</span>
<span class="fc" id="L1868">                .withBucket(bucket)</span>
<span class="fc" id="L1869">                .withOrg(org)</span>
<span class="fc" id="L1870">                .withHost(host)</span>
<span class="fc" id="L1871">                .withToken(token)</span>
<span class="fc" id="L1872">                .withTimeColumn(timeColumn)</span>
<span class="fc" id="L1873">                .withTagColumns(tagColumns)</span>
<span class="fc" id="L1874">                .withFieldFunction(fieldFn);</span>
    }

    /**
     * Convert a value to a bool.
     *
     * @return {@link ToBoolFlux}
     */
    @Nonnull
    public final ToBoolFlux toBool() {
<span class="fc" id="L1884">        return new ToBoolFlux(this);</span>
    }

    /**
     * Convert a value to a int.
     *
     * @return {@link ToIntFlux}
     */
    @Nonnull
    public final ToIntFlux toInt() {
<span class="fc" id="L1894">        return new ToIntFlux(this);</span>
    }

    /**
     * Convert a value to a float.
     *
     * @return {@link ToFloatFlux}
     */
    @Nonnull
    public final ToFloatFlux toFloat() {
<span class="fc" id="L1904">        return new ToFloatFlux(this);</span>
    }

    /**
     * Convert a value to a duration.
     *
     * @return {@link ToDurationFlux}
     */
    @Nonnull
    public final ToDurationFlux toDuration() {
<span class="fc" id="L1914">        return new ToDurationFlux(this);</span>
    }

    /**
     * Convert a value to a string.
     *
     * @return {@link ToStringFlux}
     */
    @Nonnull
    public final ToStringFlux toStringConvert() {
<span class="fc" id="L1924">        return new ToStringFlux(this);</span>
    }

    /**
     * Convert a value to a time.
     *
     * @return {@link ToTimeFlux}
     */
    @Nonnull
    public final ToTimeFlux toTime() {
<span class="fc" id="L1934">        return new ToTimeFlux(this);</span>
    }

    /**
     * Convert a value to a uint.
     *
     * @return {@link ToUIntFlux}
     */
    @Nonnull
    public final ToUIntFlux toUInt() {
<span class="fc" id="L1944">        return new ToUIntFlux(this);</span>
    }

    /**
     * Groups the results by a given time range.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link WindowFlux#withEvery(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withPeriod(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withOffset(Long, ChronoUnit)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withOffset(Instant)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withTimeColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withStartColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withStartColumn(String)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link WindowFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window() {
<span class="fc" id="L1968">        return new WindowFlux(this);</span>
    }

    /**
     * Groups the results by a given time range.
     *
     * @param every     duration of time between windows
     * @param everyUnit a {@code ChronoUnit} determining how to interpret the {@code every}
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit) {

<span class="fc" id="L1982">        Arguments.checkNotNull(every, &quot;Every is required&quot;);</span>
<span class="fc" id="L1983">        Arguments.checkNotNull(everyUnit, &quot;Every ChronoUnit is required&quot;);</span>

<span class="fc" id="L1985">        return new WindowFlux(this).withEvery(every, everyUnit);</span>
    }

    /**
     * Groups the results by a given time range.
     *
     * @param every      duration of time between windows
     * @param everyUnit  a {@code ChronoUnit} determining how to interpret the {@code every}
     * @param period     duration of the windowed partition
     * @param periodUnit a {@code ChronoUnit} determining how to interpret the {@code period}
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit,
                                   @Nonnull final Long period,
                                   @Nonnull final ChronoUnit periodUnit) {

<span class="fc" id="L2003">        Arguments.checkNotNull(every, &quot;Every is required&quot;);</span>
<span class="fc" id="L2004">        Arguments.checkNotNull(everyUnit, &quot;Every ChronoUnit is required&quot;);</span>

<span class="fc" id="L2006">        Arguments.checkNotNull(period, &quot;Period is required&quot;);</span>
<span class="fc" id="L2007">        Arguments.checkNotNull(periodUnit, &quot;Period ChronoUnit is required&quot;);</span>

<span class="fc" id="L2009">        return new WindowFlux(this)</span>
<span class="fc" id="L2010">                .withEvery(every, everyUnit)</span>
<span class="fc" id="L2011">                .withPeriod(period, periodUnit);</span>
    }

    /**
     * Groups the results by a given time range.
     *
     * @param every      duration of time between windows
     * @param everyUnit  a {@code ChronoUnit} determining how to interpret the {@code every}
     * @param period     duration of the windowed partition
     * @param periodUnit a {@code ChronoUnit} determining how to interpret the {@code period}
     * @param offset     The offset duration relative to the location offset
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit,
                                   @Nonnull final Long period,
                                   @Nonnull final ChronoUnit periodUnit,
                                   @Nonnull final Instant offset) {

<span class="fc" id="L2031">        return new WindowFlux(this)</span>
<span class="fc" id="L2032">                .withEvery(every, everyUnit)</span>
<span class="fc" id="L2033">                .withPeriod(period, periodUnit)</span>
<span class="fc" id="L2034">                .withOffset(offset);</span>
    }

    /**
     * Groups the results by a given time range.
     *
     * @param every      duration of time between windows
     * @param everyUnit  a {@code ChronoUnit} determining how to interpret the {@code every}
     * @param period     duration of the windowed partition
     * @param periodUnit a {@code ChronoUnit} determining how to interpret the {@code period}
     * @param offset     The offset duration relative to the location offset
     * @param offsetUnit a {@code ChronoUnit} determining how to interpret the {@code offset}
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit,
                                   @Nonnull final Long period,
                                   @Nonnull final ChronoUnit periodUnit,
                                   @Nonnull final Long offset,
                                   @Nonnull final ChronoUnit offsetUnit) {

<span class="fc" id="L2056">        return new WindowFlux(this)</span>
<span class="fc" id="L2057">                .withEvery(every, everyUnit)</span>
<span class="fc" id="L2058">                .withPeriod(period, periodUnit)</span>
<span class="fc" id="L2059">                .withOffset(offset, offsetUnit);</span>
    }

    /**
     * Partitions the results by a given time range.
     *
     * @param every       duration of time between windows
     * @param everyUnit   a {@code ChronoUnit} determining how to interpret the {@code every}
     * @param period      duration of the windowed partition
     * @param periodUnit  a {@code ChronoUnit} determining how to interpret the {@code period}
     * @param offset      The offset duration relative to the location offset
     * @param offsetUnit  a {@code ChronoUnit} determining how to interpret the {@code offset}
     * @param timeColumn  name of the time column to use
     * @param startColumn name of the column containing the window start time
     * @param stopColumn  name of the column containing the window stop time
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit,
                                   @Nonnull final Long period,
                                   @Nonnull final ChronoUnit periodUnit,
                                   @Nonnull final Long offset,
                                   @Nonnull final ChronoUnit offsetUnit,
                                   @Nonnull final String timeColumn,
                                   @Nonnull final String startColumn,
                                   @Nonnull final String stopColumn) {

<span class="fc" id="L2087">        return new WindowFlux(this)</span>
<span class="fc" id="L2088">                .withEvery(every, everyUnit)</span>
<span class="fc" id="L2089">                .withPeriod(period, periodUnit)</span>
<span class="fc" id="L2090">                .withOffset(offset, offsetUnit)</span>
<span class="fc" id="L2091">                .withTimeColumn(timeColumn)</span>
<span class="fc" id="L2092">                .withStartColumn(startColumn)</span>
<span class="fc" id="L2093">                .withStopCol(stopColumn);</span>

    }

    /**
     * Partitions the results by a given time range.
     *
     * @param every       duration of time between windows
     * @param everyUnit   a {@code ChronoUnit} determining how to interpret the {@code every}
     * @param period      duration of the windowed partition
     * @param periodUnit  a {@code ChronoUnit} determining how to interpret the {@code period}
     * @param offset      The offset duration relative to the location offset
     * @param timeColumn  name of the time column to use
     * @param startColumn name of the column containing the window start time
     * @param stopColumn  name of the column containing the window stop time
     * @return {@link WindowFlux}
     */
    @Nonnull
    public final WindowFlux window(@Nonnull final Long every,
                                   @Nonnull final ChronoUnit everyUnit,
                                   @Nonnull final Long period,
                                   @Nonnull final ChronoUnit periodUnit,
                                   @Nonnull final Instant offset,
                                   @Nonnull final String timeColumn,
                                   @Nonnull final String startColumn,
                                   @Nonnull final String stopColumn) {

<span class="fc" id="L2120">        return new WindowFlux(this)</span>
<span class="fc" id="L2121">                .withEvery(every, everyUnit)</span>
<span class="fc" id="L2122">                .withPeriod(period, periodUnit)</span>
<span class="fc" id="L2123">                .withOffset(offset)</span>
<span class="fc" id="L2124">                .withTimeColumn(timeColumn)</span>
<span class="fc" id="L2125">                .withStartColumn(startColumn)</span>
<span class="fc" id="L2126">                .withStopCol(stopColumn);</span>
    }

    /**
     * Yield a query results to yielded results.
     *
     * &lt;h3&gt;The parameters had to be defined by:&lt;/h3&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@link YieldFlux#withName(String)}&lt;/li&gt;
     * &lt;li&gt;{@link YieldFlux#withPropertyNamed(String)}&lt;/li&gt;
     * &lt;li&gt;{@link YieldFlux#withPropertyNamed(String, String)}&lt;/li&gt;
     * &lt;li&gt;{@link YieldFlux#withPropertyValueEscaped(String, String)}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return {@link YieldFlux}
     */
    @Nonnull
    public final YieldFlux yield() {
<span class="fc" id="L2144">        return new YieldFlux(this);</span>
    }

    /**
     * Yield a query results to yielded results.
     *
     * @param name The unique name to give to yielded results. Has to be defined.
     * @return {@link YieldFlux}
     */
    @Nonnull
    public final YieldFlux yield(@Nonnull final String name) {
<span class="fc" id="L2155">        return new YieldFlux(this).withName(name);</span>
    }

    /**
     * Write the custom Flux expression.
     *
     * @param expression flux expression
     * @return {@link ExpressionFlux}
     */
    @Nonnull
    public final ExpressionFlux expression(@Nonnull final String expression) {

<span class="fc" id="L2167">        Arguments.checkNonEmpty(expression, &quot;Expression&quot;);</span>

<span class="fc" id="L2169">        return new ExpressionFlux(this, expression);</span>
    }

    /**
     * Create new function with type {@code type}.
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .function(FilterMeasurement.class)
     *          .withName(&quot;cpu&quot;)
     *      .sum();
     * &lt;/pre&gt;
     *
     * @param type function type
     * @param &lt;F&gt;  function type
     * @return function with {@code type}
     */
    @Nonnull
    public final &lt;F extends AbstractParametrizedFlux&gt; F function(@Nonnull final Class&lt;F&gt; type) {

<span class="nc" id="L2190">        Arguments.checkNotNull(type, &quot;Function type&quot;);</span>

        try {
<span class="nc" id="L2193">            return type.getConstructor(Flux.class).newInstance(this);</span>
<span class="nc" id="L2194">        } catch (Exception e) {</span>
<span class="nc" id="L2195">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Add named property to current function.
     *
     * &lt;pre&gt;
     *  FluxChain fluxChain = new FluxChain()
     *      .withPropertyNamed(&quot;every&quot;, 15, ChronoUnit.MINUTES)
     *      .withPropertyNamed(&quot;period&quot;, 20L, ChronoUnit.SECONDS)
     *      .withPropertyNamed(&quot;start&quot;, -50, ChronoUnit.DAYS)
     *      .withPropertyNamed(&quot;round&quot;, 1L, ChronoUnit.HOURS);
     *
     *  Flux flux = Flux.from(&quot;telegraf&quot;)
     *      .window()
     *          .withPropertyNamed(&quot;every&quot;)
     *          .withPropertyNamed(&quot;period&quot;)
     *          .withPropertyNamed(&quot;start&quot;)
     *          .withPropertyNamed(&quot;round&quot;)
     *      .sum();
     *
     * flux.print(fluxChain);
     * &lt;/pre&gt;
     *
     * @param property name in Flux query and in named properties
     * @return a current function.
     */
    @Nonnull
    public final Flux withPropertyNamed(@Nonnull final String property) {
<span class="fc" id="L2225">        return withPropertyNamed(property, property);</span>
    }

    /**
     * Add named property to current function.
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .limit()
     *          .withPropertyNamed(&quot;n&quot;, &quot;limit&quot;)
     *      .sum();
     *
     * FluxChain fluxChain = new FluxChain()
     *      .withPropertyNamed(&quot;limit&quot;, 15);
     *
     * flux.print(fluxChain);
     * &lt;/pre&gt;
     *
     * @param fluxName      name in Flux query
     * @param namedProperty name in named properties
     * @return a current function
     */
    @Nonnull
    public final Flux withPropertyNamed(@Nonnull final String fluxName, @Nonnull final String namedProperty) {

<span class="fc" id="L2251">        Arguments.checkNonEmpty(fluxName, &quot;Flux property name&quot;);</span>
<span class="fc" id="L2252">        Arguments.checkNonEmpty(namedProperty, &quot;Named property&quot;);</span>

<span class="fc" id="L2254">        this.functionsParameters.putPropertyNamed(fluxName, namedProperty);</span>

<span class="fc" id="L2256">        return this;</span>
    }

    /**
     * Add property value to current function.
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .limit()
     *          .withPropertyValue(&quot;n&quot;, 5)
     *      .sum();
     * &lt;/pre&gt;
     *
     * @param propertyName name in Flux query
     * @param value        value of property. If null than ignored.
     * @return a current function
     */
    @Nonnull
    public final Flux withPropertyValue(@Nonnull final String propertyName, @Nullable final Object value) {

<span class="fc" id="L2277">        Arguments.checkNonEmpty(propertyName, &quot;Flux property name&quot;);</span>

<span class="fc" id="L2279">        this.functionsParameters.putPropertyValue(propertyName, value);</span>

<span class="fc" id="L2281">        return this;</span>
    }

    /**
     * Add named function to current function.
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .drop()
     *           .withFunction(&quot;fn&quot;, &quot;column =~ free*&quot;);
     * &lt;/pre&gt;
     *
     * @param functionName name in Flux query
     * @param function     defined function
     * @return a current function
     */
    @Nonnull
    public final Flux withFunction(@Nonnull final String functionName, @Nullable final Object function) {

<span class="fc" id="L2301">        Arguments.checkNonEmpty(functionName, &quot;functionName&quot;);</span>

<span class="fc" id="L2303">        this.functionsParameters.putFunctionValue(functionName, function);</span>

<span class="fc" id="L2305">        return this;</span>
    }

    /**
     * Add named function to current function.
     *
     * &lt;pre&gt;
     * Map&amp;lt;String, Object&amp;gt; parameters = new HashMap&amp;lt;&amp;gt;();
     * parameters.put(&quot;function&quot;, &quot;r._value * 10&quot;);
     *
     * Flux flux = Flux
     *     .from(&quot;telegraf&quot;)
     *     .range(-12L, ChronoUnit.HOURS)
     *     .map()
     *          .withFunctionNamed(&quot;fn: (r)&quot;, &quot;function&quot;);
     * &lt;/pre&gt;
     *
     * @param functionName  name in Flux query
     * @param namedProperty name in named properties
     * @return a current function
     */
    @Nonnull
    public final Flux withFunctionNamed(@Nonnull final String functionName, @Nonnull final String namedProperty) {

<span class="fc" id="L2329">        Arguments.checkNonEmpty(functionName, &quot;functionName&quot;);</span>
<span class="fc" id="L2330">        Arguments.checkNonEmpty(namedProperty, &quot;namedProperty&quot;);</span>

<span class="fc" id="L2332">        this.functionsParameters.putFunctionNamed(functionName, namedProperty);</span>

<span class="fc" id="L2334">        return this;</span>
    }

    /**
     * Add string property value to current function that will be quoted (value =&amp;gt; &quot;value&quot;).
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .window(5, ChronoUnit.MINUTES)
     *          .withPropertyValueEscaped(&quot;startColumn&quot;, &quot;differentCol&quot;)
     *      .sum();
     * &lt;/pre&gt;
     *
     * @param property name of property in Flux query
     * @param amount   the amount of the duration, measured in terms of the unit, positive or negative
     * @param unit     the unit that the duration is measured in, must have an exact duration.  If null than ignored.
     * @return a current function
     */
    @Nonnull
    public final Flux withPropertyValue(@Nonnull final String property,
                                        @Nullable final Long amount,
                                        @Nullable final ChronoUnit unit) {

<span class="fc" id="L2358">        Arguments.checkNonEmpty(property, &quot;Flux property name&quot;);</span>

<span class="fc" id="L2360">        this.functionsParameters.putPropertyValue(property, amount, unit);</span>

<span class="fc" id="L2362">        return this;</span>
    }

    /**
     * Add string property value to current function that will be quoted (value =&amp;gt; &quot;value&quot;).
     *
     * &lt;pre&gt;
     * Flux flux = Flux
     *      .from(&quot;telegraf&quot;)
     *      .window(5, ChronoUnit.MINUTES)
     *          .withPropertyValueEscaped(&quot;startColumn&quot;, &quot;differentCol&quot;)
     *      .sum();
     * &lt;/pre&gt;
     *
     * @param property name of property in Flux query
     * @param value    value of property. If null than ignored.
     * @return a current function
     */
    @Nonnull
    public final Flux withPropertyValueEscaped(@Nonnull final String property, @Nullable final String value) {

<span class="fc" id="L2383">        Arguments.checkNonEmpty(property, &quot;Flux property name&quot;);</span>

<span class="fc" id="L2385">        this.functionsParameters.putPropertyValueString(property, value);</span>

<span class="fc" id="L2387">        return this;</span>
    }

    /**
     * Append actual Flux function to Flux query.
     *
     * @param parameters named parameters for Flux query
     * @param builder    Flux query chaing
     */
    public abstract void appendActual(@Nonnull final Map&lt;String, Object&gt; parameters,
                                      @Nonnull final StringBuilder builder);

    /**
     * Create the Flux query that can be executed by FluxService.
     *
     * @return Flux query
     */
    @Nonnull
    @Override
    public String toString() {
<span class="fc" id="L2407">        return toString(new HashMap&lt;&gt;());</span>
    }

    /**
     * Create the Flux query that can be executed by FluxService.
     *
     * @param parameters flux query named parameters
     * @return Flux query
     */
    @Nonnull
    public String toString(@Nonnull final Map&lt;String, Object&gt; parameters) {

<span class="fc" id="L2419">        Arguments.checkNotNull(parameters, &quot;Parameters are required&quot;);</span>

<span class="fc" id="L2421">        StringBuilder builder = new StringBuilder();</span>

<span class="fc" id="L2423">        appendActual(parameters, builder);</span>

<span class="fc" id="L2425">        return builder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>