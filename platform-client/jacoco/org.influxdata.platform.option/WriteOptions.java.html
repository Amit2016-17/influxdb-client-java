<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriteOptions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">The Platform Client</a> &gt; <a href="index.source.html" class="el_package">org.influxdata.platform.option</a> &gt; <span class="el_source">WriteOptions.java</span></div><h1>WriteOptions.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.influxdata.platform.option;

import javax.annotation.Nonnull;
import javax.annotation.concurrent.NotThreadSafe;
import javax.annotation.concurrent.ThreadSafe;

import org.influxdata.platform.Arguments;

import io.reactivex.BackpressureOverflowStrategy;
import io.reactivex.Scheduler;
import io.reactivex.schedulers.Schedulers;

/**
 * WriteOptions are used to configure writes the data point into InfluxDB.
 *
 * &lt;p&gt;
 * The default setting use the batching configured to (consistent with Telegraf):
 * &lt;ul&gt;
 * &lt;li&gt;batchSize = 1000&lt;/li&gt;
 * &lt;li&gt;flushInterval = 1000 ms&lt;/li&gt;
 * &lt;li&gt;retryInterval = 1000 ms&lt;/li&gt;
 * &lt;li&gt;jitterInterval = 0&lt;/li&gt;
 * &lt;li&gt;bufferLimit = 10_000&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The default backpressure strategy is {@link BackpressureOverflowStrategy#DROP_OLDEST}.
 * &lt;p&gt;
 * For disabling the batching use the configuration: {@link WriteOptions#DISABLED_BATCHING}
 *
 * @author Jakub Bednar (bednar@github) (21/09/2018 10:11)
 */
@ThreadSafe
public final class WriteOptions {

    private static final int DEFAULT_BATCH_SIZE = 1000;
    private static final int DEFAULT_FLUSH_INTERVAL = 1000;
    private static final int DEFAULT_JITTER_INTERVAL = 0;
    private static final int DEFAULT_RETRY_INTERVAL = 1000;
    private static final int DEFAULT_BUFFER_LIMIT = 10000;

    /**
     * Default configuration with values that are consistent with Telegraf.
     */
<span class="fc" id="L65">    public static final WriteOptions DEFAULTS = WriteOptions.builder().build();</span>

    /**
     * Disabled batching.
     */
<span class="fc" id="L70">    public static final WriteOptions DISABLED_BATCHING = WriteOptions.disabled().build();</span>

    private final int batchSize;
    private final int flushInterval;
    private final int jitterInterval;
    private final int retryInterval;
    private final int bufferLimit;
    private final Scheduler writeScheduler;
    private final BackpressureOverflowStrategy backpressureStrategy;

    /**
     * @return the number of data point to collect in batch
     * @see WriteOptions.Builder#batchSize(int)
     */
    public int getBatchSize() {
<span class="fc" id="L85">        return batchSize;</span>
    }

    /**
     * @return the time to wait at most (milliseconds)
     * @see WriteOptions.Builder#flushInterval(int) (int)
     */
    public int getFlushInterval() {
<span class="fc" id="L93">        return flushInterval;</span>
    }

    /**
     * @return batch flush interval jitter value (milliseconds)
     * @see WriteOptions.Builder#jitterInterval(int)
     */
    public int getJitterInterval() {
<span class="fc" id="L101">        return jitterInterval;</span>
    }


    /**
     * @return the time to wait before retry unsuccessful write (milliseconds)
     * @see WriteOptions.Builder#retryInterval(int)
     */
    public int getRetryInterval() {
<span class="fc" id="L110">        return retryInterval;</span>
    }

    /**
     * @return Maximum number of points stored in the retry buffer.
     * @see WriteOptions.Builder#bufferLimit(int)
     */
    public int getBufferLimit() {
<span class="fc" id="L118">        return bufferLimit;</span>
    }

    /**
     * @return Set the scheduler which is used for write data points.
     * @see WriteOptions.Builder#writeScheduler(Scheduler)
     */
    @Nonnull
    public Scheduler getWriteScheduler() {
<span class="fc" id="L127">        return writeScheduler;</span>
    }

    /**
     * @return the strategy to deal with buffer overflow when using onBackpressureBuffer
     * @see WriteOptions.Builder#backpressureStrategy(BackpressureOverflowStrategy)
     */
    @Nonnull
    public BackpressureOverflowStrategy getBackpressureStrategy() {
<span class="fc" id="L136">        return backpressureStrategy;</span>
    }

<span class="fc" id="L139">    private WriteOptions(@Nonnull final Builder builder) {</span>

<span class="fc" id="L141">        Arguments.checkNotNull(builder, &quot;WriteOptions.Builder&quot;);</span>

<span class="fc" id="L143">        batchSize = builder.batchSize;</span>
<span class="fc" id="L144">        flushInterval = builder.flushInterval;</span>
<span class="fc" id="L145">        jitterInterval = builder.jitterInterval;</span>
<span class="fc" id="L146">        retryInterval = builder.retryInterval;</span>
<span class="fc" id="L147">        bufferLimit = builder.bufferLimit;</span>
<span class="fc" id="L148">        writeScheduler = builder.writeScheduler;</span>
<span class="fc" id="L149">        backpressureStrategy = builder.backpressureStrategy;</span>
<span class="fc" id="L150">    }</span>

    /**
     * Creates a builder instance.
     *
     * @return a builder
     */
    @Nonnull
    public static WriteOptions.Builder builder() {
<span class="fc" id="L159">        return new WriteOptions.Builder();</span>
    }

    /**
     * Creates a builder instance with disabled batching. The {@link WriteOptions#getBatchSize()} is set to 1
     * and {@link WriteOptions#getWriteScheduler()} is set to {@link Schedulers#io()}.
     *
     * @return a builder
     */
    @Nonnull
    public static WriteOptions.Builder disabled() {
<span class="fc" id="L170">        return WriteOptions.builder().batchSize(1).writeScheduler(Schedulers.single());</span>
    }

    /**
     * A builder for {@code WriteOptions}.
     */
    @NotThreadSafe
<span class="fc" id="L177">    public static class Builder {</span>

<span class="fc" id="L179">        private int batchSize = DEFAULT_BATCH_SIZE;</span>
<span class="fc" id="L180">        private int flushInterval = DEFAULT_FLUSH_INTERVAL;</span>
<span class="fc" id="L181">        private int jitterInterval = DEFAULT_JITTER_INTERVAL;</span>
<span class="fc" id="L182">        private int retryInterval = DEFAULT_RETRY_INTERVAL;</span>
<span class="fc" id="L183">        private int bufferLimit = DEFAULT_BUFFER_LIMIT;</span>
<span class="fc" id="L184">        private Scheduler writeScheduler = Schedulers.trampoline();</span>
<span class="fc" id="L185">        private BackpressureOverflowStrategy backpressureStrategy = BackpressureOverflowStrategy.DROP_OLDEST;</span>

        /**
         * Set the number of data point to collect in batch.
         *
         * @param batchSize the number of data point to collect in batch
         * @return {@code this}
         */
        @Nonnull
        public Builder batchSize(final int batchSize) {
<span class="fc" id="L195">            Arguments.checkPositiveNumber(batchSize, &quot;batchSize&quot;);</span>
<span class="fc" id="L196">            this.batchSize = batchSize;</span>
<span class="fc" id="L197">            return this;</span>
        }

        /**
         * Set the time to wait at most (milliseconds).
         *
         * @param flushInterval the time to wait at most (milliseconds).
         * @return {@code this}
         */
        @Nonnull
        public Builder flushInterval(final int flushInterval) {
<span class="fc" id="L208">            Arguments.checkPositiveNumber(flushInterval, &quot;flushInterval&quot;);</span>
<span class="fc" id="L209">            this.flushInterval = flushInterval;</span>
<span class="fc" id="L210">            return this;</span>
        }

        /**
         * Jitters the batch flush interval by a random amount. This is primarily to avoid
         * large write spikes for users running a large number of client instances.
         * ie, a jitter of 5s and flush duration 10s means flushes will happen every 10-15s.
         *
         * @param jitterInterval (milliseconds)
         * @return {@code this}
         */
        @Nonnull
        public Builder jitterInterval(final int jitterInterval) {
<span class="fc" id="L223">            Arguments.checkNotNegativeNumber(jitterInterval, &quot;jitterInterval&quot;);</span>
<span class="fc" id="L224">            this.jitterInterval = jitterInterval;</span>
<span class="fc" id="L225">            return this;</span>
        }

        /**
         * Set the the time to wait before retry unsuccessful write (milliseconds).
         *
         * @param retryInterval the time to wait before retry unsuccessful write
         * @return {@code this}
         */
        @Nonnull
        public Builder retryInterval(final int retryInterval) {
<span class="fc" id="L236">            Arguments.checkPositiveNumber(retryInterval, &quot;retryInterval&quot;);</span>
<span class="fc" id="L237">            this.retryInterval = retryInterval;</span>
<span class="fc" id="L238">            return this;</span>
        }

        /**
         * The client maintains a buffer for failed writes so that the writes will be retried later on. This may
         * help to overcome temporary network problems or InfluxDB load spikes.
         * When the buffer is full and new points are written, oldest entries in the buffer are lost.
         *
         * @param bufferLimit maximum number of points stored in the retry buffer
         * @return {@code this}
         */
        @Nonnull
        public Builder bufferLimit(final int bufferLimit) {
<span class="fc" id="L251">            Arguments.checkNotNegativeNumber(bufferLimit, &quot;bufferLimit&quot;);</span>
<span class="fc" id="L252">            this.bufferLimit = bufferLimit;</span>
<span class="fc" id="L253">            return this;</span>
        }

        /**
         * Set the scheduler which is used for write data points. It is useful for disabling batch writes or
         * for tuning the performance. Default value is {@link Schedulers#trampoline()}.
         *
         * @param writeScheduler the scheduler which is used for write data points.
         * @return {@code this}
         */
        @Nonnull
        public Builder writeScheduler(@Nonnull final Scheduler writeScheduler) {

<span class="fc" id="L266">            Arguments.checkNotNull(writeScheduler, &quot;Write scheduler&quot;);</span>

<span class="fc" id="L268">            this.writeScheduler = writeScheduler;</span>
<span class="fc" id="L269">            return this;</span>
        }

        /**
         * Set the strategy to deal with buffer overflow when using onBackpressureBuffer.
         *
         * @param backpressureStrategy the strategy to deal with buffer overflow when using onBackpressureBuffer.
         *                             Default {@link BackpressureOverflowStrategy#DROP_OLDEST};
         * @return {@code this}
         */
        @Nonnull
        public Builder backpressureStrategy(@Nonnull final BackpressureOverflowStrategy backpressureStrategy) {
<span class="fc" id="L281">            Arguments.checkNotNull(backpressureStrategy, &quot;Backpressure Overflow Strategy&quot;);</span>
<span class="fc" id="L282">            this.backpressureStrategy = backpressureStrategy;</span>
<span class="fc" id="L283">            return this;</span>
        }

        /**
         * Build an instance of WriteOptions.
         *
         * @return {@code WriteOptions}
         */
        @Nonnull
        public WriteOptions build() {

<span class="fc" id="L294">            return new WriteOptions(this);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>